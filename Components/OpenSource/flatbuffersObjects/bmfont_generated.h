// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BMFONT_BMFONT_H_
#define FLATBUFFERS_GENERATED_BMFONT_BMFONT_H_

#include "../flatbuffers/flatbuffers.h"

namespace BMFont {

struct bmFont_t;
struct bmFont_tBuilder;

struct info_t;
struct info_tBuilder;

struct common_t;
struct common_tBuilder;

struct char_t;
struct char_tBuilder;

struct bmFont_t FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef bmFont_tBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAGES = 4,
    VT_KERNINGS = 6,
    VT_INFO = 8,
    VT_COMMON = 10,
    VT_CHARS = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *pages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PAGES);
  }
  const flatbuffers::Vector<int16_t> *kernings() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_KERNINGS);
  }
  const BMFont::info_t *info() const {
    return GetPointer<const BMFont::info_t *>(VT_INFO);
  }
  const BMFont::common_t *common() const {
    return GetPointer<const BMFont::common_t *>(VT_COMMON);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BMFont::char_t>> *chars() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BMFont::char_t>> *>(VT_CHARS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAGES) &&
           verifier.VerifyVector(pages()) &&
           verifier.VerifyVectorOfStrings(pages()) &&
           VerifyOffset(verifier, VT_KERNINGS) &&
           verifier.VerifyVector(kernings()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_CHARS) &&
           verifier.VerifyVector(chars()) &&
           verifier.VerifyVectorOfTables(chars()) &&
           verifier.EndTable();
  }
};

struct bmFont_tBuilder {
  typedef bmFont_t Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> pages) {
    fbb_.AddOffset(bmFont_t::VT_PAGES, pages);
  }
  void add_kernings(flatbuffers::Offset<flatbuffers::Vector<int16_t>> kernings) {
    fbb_.AddOffset(bmFont_t::VT_KERNINGS, kernings);
  }
  void add_info(flatbuffers::Offset<BMFont::info_t> info) {
    fbb_.AddOffset(bmFont_t::VT_INFO, info);
  }
  void add_common(flatbuffers::Offset<BMFont::common_t> common) {
    fbb_.AddOffset(bmFont_t::VT_COMMON, common);
  }
  void add_chars(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BMFont::char_t>>> chars) {
    fbb_.AddOffset(bmFont_t::VT_CHARS, chars);
  }
  explicit bmFont_tBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  bmFont_tBuilder &operator=(const bmFont_tBuilder &);
  flatbuffers::Offset<bmFont_t> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<bmFont_t>(end);
    return o;
  }
};

inline flatbuffers::Offset<bmFont_t> CreatebmFont_t(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> pages = 0,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> kernings = 0,
    flatbuffers::Offset<BMFont::info_t> info = 0,
    flatbuffers::Offset<BMFont::common_t> common = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BMFont::char_t>>> chars = 0) {
  bmFont_tBuilder builder_(_fbb);
  builder_.add_chars(chars);
  builder_.add_common(common);
  builder_.add_info(info);
  builder_.add_kernings(kernings);
  builder_.add_pages(pages);
  return builder_.Finish();
}

inline flatbuffers::Offset<bmFont_t> CreatebmFont_tDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *pages = nullptr,
    const std::vector<int16_t> *kernings = nullptr,
    flatbuffers::Offset<BMFont::info_t> info = 0,
    flatbuffers::Offset<BMFont::common_t> common = 0,
    std::vector<flatbuffers::Offset<BMFont::char_t>> *chars = nullptr) {
  auto pages__ = pages ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*pages) : 0;
  auto kernings__ = kernings ? _fbb.CreateVector<int16_t>(*kernings) : 0;
  auto chars__ = chars ? _fbb.CreateVectorOfSortedTables<BMFont::char_t>(chars) : 0;
  return BMFont::CreatebmFont_t(
      _fbb,
      pages__,
      kernings__,
      info,
      common,
      chars__);
}

struct info_t FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef info_tBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FACE = 4,
    VT_SIZE = 6,
    VT_BOLD = 8,
    VT_ITALIC = 10,
    VT_CHARSET = 12,
    VT_UNICODE = 14,
    VT_STRETCHH = 16,
    VT_SMOOTH = 18,
    VT_AA = 20,
    VT_PADDING = 22,
    VT_SPACING = 24,
    VT_OUTLINE = 26
  };
  const flatbuffers::String *face() const {
    return GetPointer<const flatbuffers::String *>(VT_FACE);
  }
  int16_t size() const {
    return GetField<int16_t>(VT_SIZE, 0);
  }
  bool bold() const {
    return GetField<uint8_t>(VT_BOLD, 0) != 0;
  }
  bool italic() const {
    return GetField<uint8_t>(VT_ITALIC, 0) != 0;
  }
  const flatbuffers::String *charset() const {
    return GetPointer<const flatbuffers::String *>(VT_CHARSET);
  }
  bool unicode() const {
    return GetField<uint8_t>(VT_UNICODE, 0) != 0;
  }
  float stretchH() const {
    return GetField<float>(VT_STRETCHH, 100.0f);
  }
  bool smooth() const {
    return GetField<uint8_t>(VT_SMOOTH, 0) != 0;
  }
  int16_t aa() const {
    return GetField<int16_t>(VT_AA, 0);
  }
  const flatbuffers::Vector<int16_t> *padding() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_PADDING);
  }
  const flatbuffers::Vector<int16_t> *spacing() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_SPACING);
  }
  int16_t outline() const {
    return GetField<int16_t>(VT_OUTLINE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FACE) &&
           verifier.VerifyString(face()) &&
           VerifyField<int16_t>(verifier, VT_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_BOLD) &&
           VerifyField<uint8_t>(verifier, VT_ITALIC) &&
           VerifyOffset(verifier, VT_CHARSET) &&
           verifier.VerifyString(charset()) &&
           VerifyField<uint8_t>(verifier, VT_UNICODE) &&
           VerifyField<float>(verifier, VT_STRETCHH) &&
           VerifyField<uint8_t>(verifier, VT_SMOOTH) &&
           VerifyField<int16_t>(verifier, VT_AA) &&
           VerifyOffset(verifier, VT_PADDING) &&
           verifier.VerifyVector(padding()) &&
           VerifyOffset(verifier, VT_SPACING) &&
           verifier.VerifyVector(spacing()) &&
           VerifyField<int16_t>(verifier, VT_OUTLINE) &&
           verifier.EndTable();
  }
};

struct info_tBuilder {
  typedef info_t Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_face(flatbuffers::Offset<flatbuffers::String> face) {
    fbb_.AddOffset(info_t::VT_FACE, face);
  }
  void add_size(int16_t size) {
    fbb_.AddElement<int16_t>(info_t::VT_SIZE, size, 0);
  }
  void add_bold(bool bold) {
    fbb_.AddElement<uint8_t>(info_t::VT_BOLD, static_cast<uint8_t>(bold), 0);
  }
  void add_italic(bool italic) {
    fbb_.AddElement<uint8_t>(info_t::VT_ITALIC, static_cast<uint8_t>(italic), 0);
  }
  void add_charset(flatbuffers::Offset<flatbuffers::String> charset) {
    fbb_.AddOffset(info_t::VT_CHARSET, charset);
  }
  void add_unicode(bool unicode) {
    fbb_.AddElement<uint8_t>(info_t::VT_UNICODE, static_cast<uint8_t>(unicode), 0);
  }
  void add_stretchH(float stretchH) {
    fbb_.AddElement<float>(info_t::VT_STRETCHH, stretchH, 100.0f);
  }
  void add_smooth(bool smooth) {
    fbb_.AddElement<uint8_t>(info_t::VT_SMOOTH, static_cast<uint8_t>(smooth), 0);
  }
  void add_aa(int16_t aa) {
    fbb_.AddElement<int16_t>(info_t::VT_AA, aa, 0);
  }
  void add_padding(flatbuffers::Offset<flatbuffers::Vector<int16_t>> padding) {
    fbb_.AddOffset(info_t::VT_PADDING, padding);
  }
  void add_spacing(flatbuffers::Offset<flatbuffers::Vector<int16_t>> spacing) {
    fbb_.AddOffset(info_t::VT_SPACING, spacing);
  }
  void add_outline(int16_t outline) {
    fbb_.AddElement<int16_t>(info_t::VT_OUTLINE, outline, 0);
  }
  explicit info_tBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  info_tBuilder &operator=(const info_tBuilder &);
  flatbuffers::Offset<info_t> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<info_t>(end);
    return o;
  }
};

inline flatbuffers::Offset<info_t> Createinfo_t(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> face = 0,
    int16_t size = 0,
    bool bold = false,
    bool italic = false,
    flatbuffers::Offset<flatbuffers::String> charset = 0,
    bool unicode = false,
    float stretchH = 100.0f,
    bool smooth = false,
    int16_t aa = 0,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> padding = 0,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> spacing = 0,
    int16_t outline = 0) {
  info_tBuilder builder_(_fbb);
  builder_.add_spacing(spacing);
  builder_.add_padding(padding);
  builder_.add_stretchH(stretchH);
  builder_.add_charset(charset);
  builder_.add_face(face);
  builder_.add_outline(outline);
  builder_.add_aa(aa);
  builder_.add_size(size);
  builder_.add_smooth(smooth);
  builder_.add_unicode(unicode);
  builder_.add_italic(italic);
  builder_.add_bold(bold);
  return builder_.Finish();
}

inline flatbuffers::Offset<info_t> Createinfo_tDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *face = nullptr,
    int16_t size = 0,
    bool bold = false,
    bool italic = false,
    const char *charset = nullptr,
    bool unicode = false,
    float stretchH = 100.0f,
    bool smooth = false,
    int16_t aa = 0,
    const std::vector<int16_t> *padding = nullptr,
    const std::vector<int16_t> *spacing = nullptr,
    int16_t outline = 0) {
  auto face__ = face ? _fbb.CreateString(face) : 0;
  auto charset__ = charset ? _fbb.CreateString(charset) : 0;
  auto padding__ = padding ? _fbb.CreateVector<int16_t>(*padding) : 0;
  auto spacing__ = spacing ? _fbb.CreateVector<int16_t>(*spacing) : 0;
  return BMFont::Createinfo_t(
      _fbb,
      face__,
      size,
      bold,
      italic,
      charset__,
      unicode,
      stretchH,
      smooth,
      aa,
      padding__,
      spacing__,
      outline);
}

struct common_t FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef common_tBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINEHEIGHT = 4,
    VT_BASE = 6,
    VT_SCALEW = 8,
    VT_SCALEH = 10,
    VT_PAGES = 12,
    VT_PACKED = 14,
    VT_ALPHACHNL = 16,
    VT_REDCHNL = 18,
    VT_GREENCHNL = 20,
    VT_BLUECHNL = 22
  };
  int16_t lineHeight() const {
    return GetField<int16_t>(VT_LINEHEIGHT, 0);
  }
  int16_t base() const {
    return GetField<int16_t>(VT_BASE, 0);
  }
  float scaleW() const {
    return GetField<float>(VT_SCALEW, 100.0f);
  }
  float scaleH() const {
    return GetField<float>(VT_SCALEH, 100.0f);
  }
  int16_t pages() const {
    return GetField<int16_t>(VT_PAGES, 1);
  }
  int16_t packed() const {
    return GetField<int16_t>(VT_PACKED, 0);
  }
  int16_t alphaChnl() const {
    return GetField<int16_t>(VT_ALPHACHNL, 0);
  }
  int16_t redChnl() const {
    return GetField<int16_t>(VT_REDCHNL, 0);
  }
  int16_t greenChnl() const {
    return GetField<int16_t>(VT_GREENCHNL, 0);
  }
  int16_t blueChnl() const {
    return GetField<int16_t>(VT_BLUECHNL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_LINEHEIGHT) &&
           VerifyField<int16_t>(verifier, VT_BASE) &&
           VerifyField<float>(verifier, VT_SCALEW) &&
           VerifyField<float>(verifier, VT_SCALEH) &&
           VerifyField<int16_t>(verifier, VT_PAGES) &&
           VerifyField<int16_t>(verifier, VT_PACKED) &&
           VerifyField<int16_t>(verifier, VT_ALPHACHNL) &&
           VerifyField<int16_t>(verifier, VT_REDCHNL) &&
           VerifyField<int16_t>(verifier, VT_GREENCHNL) &&
           VerifyField<int16_t>(verifier, VT_BLUECHNL) &&
           verifier.EndTable();
  }
};

struct common_tBuilder {
  typedef common_t Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lineHeight(int16_t lineHeight) {
    fbb_.AddElement<int16_t>(common_t::VT_LINEHEIGHT, lineHeight, 0);
  }
  void add_base(int16_t base) {
    fbb_.AddElement<int16_t>(common_t::VT_BASE, base, 0);
  }
  void add_scaleW(float scaleW) {
    fbb_.AddElement<float>(common_t::VT_SCALEW, scaleW, 100.0f);
  }
  void add_scaleH(float scaleH) {
    fbb_.AddElement<float>(common_t::VT_SCALEH, scaleH, 100.0f);
  }
  void add_pages(int16_t pages) {
    fbb_.AddElement<int16_t>(common_t::VT_PAGES, pages, 1);
  }
  void add_packed(int16_t packed) {
    fbb_.AddElement<int16_t>(common_t::VT_PACKED, packed, 0);
  }
  void add_alphaChnl(int16_t alphaChnl) {
    fbb_.AddElement<int16_t>(common_t::VT_ALPHACHNL, alphaChnl, 0);
  }
  void add_redChnl(int16_t redChnl) {
    fbb_.AddElement<int16_t>(common_t::VT_REDCHNL, redChnl, 0);
  }
  void add_greenChnl(int16_t greenChnl) {
    fbb_.AddElement<int16_t>(common_t::VT_GREENCHNL, greenChnl, 0);
  }
  void add_blueChnl(int16_t blueChnl) {
    fbb_.AddElement<int16_t>(common_t::VT_BLUECHNL, blueChnl, 0);
  }
  explicit common_tBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  common_tBuilder &operator=(const common_tBuilder &);
  flatbuffers::Offset<common_t> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<common_t>(end);
    return o;
  }
};

inline flatbuffers::Offset<common_t> Createcommon_t(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t lineHeight = 0,
    int16_t base = 0,
    float scaleW = 100.0f,
    float scaleH = 100.0f,
    int16_t pages = 1,
    int16_t packed = 0,
    int16_t alphaChnl = 0,
    int16_t redChnl = 0,
    int16_t greenChnl = 0,
    int16_t blueChnl = 0) {
  common_tBuilder builder_(_fbb);
  builder_.add_scaleH(scaleH);
  builder_.add_scaleW(scaleW);
  builder_.add_blueChnl(blueChnl);
  builder_.add_greenChnl(greenChnl);
  builder_.add_redChnl(redChnl);
  builder_.add_alphaChnl(alphaChnl);
  builder_.add_packed(packed);
  builder_.add_pages(pages);
  builder_.add_base(base);
  builder_.add_lineHeight(lineHeight);
  return builder_.Finish();
}

struct char_t FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef char_tBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_WIDTH = 10,
    VT_HEIGHT = 12,
    VT_XOFFSET = 14,
    VT_YOFFSET = 16,
    VT_XADVANCE = 18,
    VT_PAGE = 20,
    VT_CHNL = 22,
    VT_LETTER = 24
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool KeyCompareLessThan(const char_t *o) const {
    return id() < o->id();
  }
  int KeyCompareWithValue(int32_t val) const {
    return static_cast<int>(id() > val) - static_cast<int>(id() < val);
  }
  int16_t x() const {
    return GetField<int16_t>(VT_X, 0);
  }
  int16_t y() const {
    return GetField<int16_t>(VT_Y, 0);
  }
  int16_t width() const {
    return GetField<int16_t>(VT_WIDTH, 0);
  }
  int16_t height() const {
    return GetField<int16_t>(VT_HEIGHT, 0);
  }
  int16_t xoffset() const {
    return GetField<int16_t>(VT_XOFFSET, 0);
  }
  int16_t yoffset() const {
    return GetField<int16_t>(VT_YOFFSET, 0);
  }
  int16_t xadvance() const {
    return GetField<int16_t>(VT_XADVANCE, 0);
  }
  int16_t page() const {
    return GetField<int16_t>(VT_PAGE, 0);
  }
  int16_t chnl() const {
    return GetField<int16_t>(VT_CHNL, 0);
  }
  const flatbuffers::String *letter() const {
    return GetPointer<const flatbuffers::String *>(VT_LETTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int16_t>(verifier, VT_X) &&
           VerifyField<int16_t>(verifier, VT_Y) &&
           VerifyField<int16_t>(verifier, VT_WIDTH) &&
           VerifyField<int16_t>(verifier, VT_HEIGHT) &&
           VerifyField<int16_t>(verifier, VT_XOFFSET) &&
           VerifyField<int16_t>(verifier, VT_YOFFSET) &&
           VerifyField<int16_t>(verifier, VT_XADVANCE) &&
           VerifyField<int16_t>(verifier, VT_PAGE) &&
           VerifyField<int16_t>(verifier, VT_CHNL) &&
           VerifyOffset(verifier, VT_LETTER) &&
           verifier.VerifyString(letter()) &&
           verifier.EndTable();
  }
};

struct char_tBuilder {
  typedef char_t Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(char_t::VT_ID, id, 0);
  }
  void add_x(int16_t x) {
    fbb_.AddElement<int16_t>(char_t::VT_X, x, 0);
  }
  void add_y(int16_t y) {
    fbb_.AddElement<int16_t>(char_t::VT_Y, y, 0);
  }
  void add_width(int16_t width) {
    fbb_.AddElement<int16_t>(char_t::VT_WIDTH, width, 0);
  }
  void add_height(int16_t height) {
    fbb_.AddElement<int16_t>(char_t::VT_HEIGHT, height, 0);
  }
  void add_xoffset(int16_t xoffset) {
    fbb_.AddElement<int16_t>(char_t::VT_XOFFSET, xoffset, 0);
  }
  void add_yoffset(int16_t yoffset) {
    fbb_.AddElement<int16_t>(char_t::VT_YOFFSET, yoffset, 0);
  }
  void add_xadvance(int16_t xadvance) {
    fbb_.AddElement<int16_t>(char_t::VT_XADVANCE, xadvance, 0);
  }
  void add_page(int16_t page) {
    fbb_.AddElement<int16_t>(char_t::VT_PAGE, page, 0);
  }
  void add_chnl(int16_t chnl) {
    fbb_.AddElement<int16_t>(char_t::VT_CHNL, chnl, 0);
  }
  void add_letter(flatbuffers::Offset<flatbuffers::String> letter) {
    fbb_.AddOffset(char_t::VT_LETTER, letter);
  }
  explicit char_tBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  char_tBuilder &operator=(const char_tBuilder &);
  flatbuffers::Offset<char_t> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<char_t>(end);
    return o;
  }
};

inline flatbuffers::Offset<char_t> Createchar_t(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int16_t x = 0,
    int16_t y = 0,
    int16_t width = 0,
    int16_t height = 0,
    int16_t xoffset = 0,
    int16_t yoffset = 0,
    int16_t xadvance = 0,
    int16_t page = 0,
    int16_t chnl = 0,
    flatbuffers::Offset<flatbuffers::String> letter = 0) {
  char_tBuilder builder_(_fbb);
  builder_.add_letter(letter);
  builder_.add_id(id);
  builder_.add_chnl(chnl);
  builder_.add_page(page);
  builder_.add_xadvance(xadvance);
  builder_.add_yoffset(yoffset);
  builder_.add_xoffset(xoffset);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

inline flatbuffers::Offset<char_t> Createchar_tDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int16_t x = 0,
    int16_t y = 0,
    int16_t width = 0,
    int16_t height = 0,
    int16_t xoffset = 0,
    int16_t yoffset = 0,
    int16_t xadvance = 0,
    int16_t page = 0,
    int16_t chnl = 0,
    const char *letter = nullptr) {
  auto letter__ = letter ? _fbb.CreateString(letter) : 0;
  return BMFont::Createchar_t(
      _fbb,
      id,
      x,
      y,
      width,
      height,
      xoffset,
      yoffset,
      xadvance,
      page,
      chnl,
      letter__);
}

inline const BMFont::bmFont_t *GetbmFont_t(const void *buf) {
  return flatbuffers::GetRoot<BMFont::bmFont_t>(buf);
}

inline const BMFont::bmFont_t *GetSizePrefixedbmFont_t(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<BMFont::bmFont_t>(buf);
}

inline bool VerifybmFont_tBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<BMFont::bmFont_t>(nullptr);
}

inline bool VerifySizePrefixedbmFont_tBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<BMFont::bmFont_t>(nullptr);
}

inline void FinishbmFont_tBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<BMFont::bmFont_t> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedbmFont_tBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<BMFont::bmFont_t> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace BMFont

#endif  // FLATBUFFERS_GENERATED_BMFONT_BMFONT_H_
